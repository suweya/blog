<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>﻿Security with HTTPS and SSL | 迷途</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="http://developer.android.com/training/articles/security-ssl.html
The Secure Sockets Layer (SSL)—now technically known as Transport Layer Security (TLS)—is a common building block for encrypted communi">
<meta property="og:type" content="article">
<meta property="og:title" content="﻿Security with HTTPS and SSL">
<meta property="og:url" content="http://blog.suweya.net/2014/12/25/android-https/">
<meta property="og:site_name" content="迷途">
<meta property="og:description" content="http://developer.android.com/training/articles/security-ssl.html
The Secure Sockets Layer (SSL)—now technically known as Transport Layer Security (TLS)—is a common building block for encrypted communi">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="﻿Security with HTTPS and SSL">
<meta name="twitter:description" content="http://developer.android.com/training/articles/security-ssl.html
The Secure Sockets Layer (SSL)—now technically known as Transport Layer Security (TLS)—is a common building block for encrypted communi">

  
    <link rel="alternative" href="/atom.xml" title="迷途" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">

  <script src="http://libs.baidu.com/jquery/1.9.0/jquery.js"></script>

  <script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?5ff76dba172ffefae7010fd357566dc1";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>


</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			<img lazy-src="http://bcs.duapp.com/suweyablog/avatar.png" class="js-avatar">
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">迷途</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/suweya" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/suweya" title="weibo">weibo</a>
					        
								<a class="google" target="_blank" href="https://plus.google.com/101772966739687843526/posts" title="google">google</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Android/" style="font-size: NaNpx;">Android</a><a href="/tags/Android-Animation/" style="font-size: NaNpx;">Android Animation</a><a href="/tags/Google/" style="font-size: NaNpx;">Google</a><a href="/tags/Image/" style="font-size: NaNpx;">Image</a><a href="/tags/Markdown/" style="font-size: NaNpx;">Markdown</a><a href="/tags/Plan-2015/" style="font-size: NaNpx;">Plan 2015</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">A not famous android developer &lt;br /&gt; Contact me -&gt; suweya@foxmail.com</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">迷途</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="http://bcs.duapp.com/suweyablog/avatar.png" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">迷途</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/suweya" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/suweya" title="weibo">weibo</a>
			        
						<a class="google" target="_blank" href="https://plus.google.com/101772966739687843526/posts" title="google">google</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap"><article id="post-android-https" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/12/25/android-https/" class="article-date">
  	<time datetime="2014-12-25T03:36:10.000Z" itemprop="datePublished">12月 25 2014</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      ﻿Security with HTTPS and SSL
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
        

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="http://developer.android.com/training/articles/security-ssl.html" target="_blank" rel="external">http://developer.android.com/training/articles/security-ssl.html</a></p>
<p>The Secure Sockets Layer (SSL)—now technically known as Transport Layer Security (TLS)—is a common building block for encrypted communications between clients and servers. It’s possible that an application might use SSL incorrectly such that malicious entities may be able to intercept an app’s data over the network. To help you ensure that this does not happen to your app, this article highlights the common pitfalls when using secure network protocols and addresses some larger concerns about using Public-Key Infrastructure (PKI). </p>
<a id="more"></a>

<h2 id="Concepts">Concepts</h2>
<p>In a typical SSL usage scenario, a server is configured with a certificate containing a public key as well as a matching private key. As part of the handshake between an SSL client and server, the server proves it has the private key by signing its certificate with public-key cryptography.</p>
<p>However, anyone can generate their own certificate and private key, so a simple handshake doesn’t prove anything about the server other than that the server knows the private key that matches the public key of the certificate. One way to solve this problem is to have the client have a set of one or more certificates it trusts. If the certificate is not in the set, the server is not to be trusted.</p>
<p>There are several downsides to this simple approach. Servers should be able to upgrade to stronger keys over time (“key rotation”), which replaces the public key in the certificate with a new one. Unfortunately, now the client app has to be updated due to what is essentially a server configuration change. This is especially problematic if the server is not under the app developer’s control, for example if it is a third party web service. This approach also has issues if the app has to talk to arbitrary servers such as a web browser or email app.</p>
<p>In order to address these downsides, servers are typically configured with certificates from well known issuers called Certificate Authorities (CAs). The host platform generally contains a list of well known CAs that it trusts. As of Android 4.2 (Jelly Bean), Android currently contains over 100 CAs that are updated in each release. Similar to a server, a CA has a certificate and a private key. When issuing a certificate for a server, the CA signs the server certificate using its private key. The client can then verify that the server has a certificate issued by a CA known to the platform.</p>
<p>However, while solving some problems, using CAs introduces another. Because the CA issues certificates for many servers, you still need some way to make sure you are talking to the server you want. To address this, the certificate issued by the CA identifies the server either with a specific name such as gmail.com or a wildcarded set of hosts such as *.google.com. </p>
<p>The following example will make these concepts a little more concrete. In the snippet below from a command line, the openssl tool’s s_client command looks at Wikipedia’s server certificate information. It specifies port 443 because that is the default for HTTPS. The command sends the output of openssl s_client to openssl x509, which formats information about certificates according to the X.509 standard. Specifically, the command asks for the subject, which contains the server name information, and the issuer, which identifies the CA.</p>
<pre><code>$ openssl s_client -connect wikipedia.org:<span class="number">443</span> | openssl x509 -noout -subject -issuer
<span class="variable">subject=</span> /<span class="variable">serialNumber=</span>sOrr2rKpMVP70Z6E9BT5reY008SJEdYv/<span class="variable">C=</span>US/<span class="variable">O=</span>*.wikipedia.org/<span class="variable">OU=</span>GT03314600/<span class="variable">OU=</span>See www.rapidssl.com/resources/cps (c)<span class="number">11</span>/<span class="variable">OU=</span>Domain Control Validated - RapidSSL(R)/<span class="variable">CN=</span>*.wikipedia.org
<span class="variable">issuer=</span> /<span class="variable">C=</span>US/<span class="variable">O=</span>GeoTrust, Inc./<span class="variable">CN=</span>RapidSSL CA
</code></pre><p>You can see that the certificate was issued for servers matching *.wikipedia.org by the RapidSSL CA.</p>
<h2 id="An_HTTPS_Example">An HTTPS Example</h2>
<p>Assuming you have a web server with a certificate issued by a well known CA, you can make a secure request with code as simple this:</p>
<pre><code>URL url = <span class="keyword">new</span> URL(<span class="string">"https://wikipedia.org"</span>);
URLConnection urlConnection = url.openConnection();
InputStream <span class="keyword">in</span> = urlConnection.getInputStr();
copyInputStreamToOutputStream(<span class="keyword">in</span>, System.<span class="keyword">out</span>);
</code></pre><p>Yes, it really can be that simple. If you want to tailor the HTTP request, you can cast to an HttpURLConnection. The Android documentation for HttpURLConnection has further examples about how to deal with request and response headers, posting content, managing cookies, using proxies, caching responses, and so on. But in terms of the details for verifying certificates and hostnames, the Android framework takes care of it for you through these APIs. This is where you want to be if at all possible. That said, below are some other considerations.</p>
<h2 id="Common_Problems_Verifying_Server_Certificates">Common Problems Verifying Server Certificates</h2>
<p>Suppose instead of receiving the content from getInputStream(), it throws an exception:</p>
<pre><code>javax.net.ssl.SSLHandshakeException: java.security.cert.CertPathValidatorException: Trust anchor <span class="keyword">for</span> certification path <span class="operator">not</span> found.
        <span class="keyword">at</span> org.apache.harmony.xnet.provider.jsse.OpenSSLSocketImpl.startHandshake(OpenSSLSocketImpl.java:<span class="number">374</span>)
        <span class="keyword">at</span> libcore.net.<span class="keyword">http</span>.HttpConnection.setupSecureSocket(HttpConnection.java:<span class="number">209</span>)
        <span class="keyword">at</span> libcore.net.<span class="keyword">http</span>.HttpsURLConnectionImpl$HttpsEngine.makeSslConnection(HttpsURLConnectionImpl.java:<span class="number">478</span>)
        <span class="keyword">at</span> libcore.net.<span class="keyword">http</span>.HttpsURLConnectionImpl$HttpsEngine.connect(HttpsURLConnectionImpl.java:<span class="number">433</span>)
        <span class="keyword">at</span> libcore.net.<span class="keyword">http</span>.HttpEngine.sendSocketRequest(HttpEngine.java:<span class="number">290</span>)
        <span class="keyword">at</span> libcore.net.<span class="keyword">http</span>.HttpEngine.sendRequest(HttpEngine.java:<span class="number">240</span>)
        <span class="keyword">at</span> libcore.net.<span class="keyword">http</span>.HttpURLConnectionImpl.getResponse(HttpURLConnectionImpl.java:<span class="number">282</span>)
        <span class="keyword">at</span> libcore.net.<span class="keyword">http</span>.HttpURLConnectionImpl.getInputStream(HttpURLConnectionImpl.java:<span class="number">177</span>)
        <span class="keyword">at</span> libcore.net.<span class="keyword">http</span>.HttpsURLConnectionImpl.getInputStream(HttpsURLConnectionImpl.java:<span class="number">271</span>)
</code></pre><p>This can happen for several reasons, including: </p>
<ol>
<li>The CA that issued the server certificate was unknown</li>
<li>The server certificate wasn’t signed by a CA, but was self signed</li>
<li>The server configuration is missing an intermediate CA</li>
</ol>
<p>The following sections discuss how to address these problems while keeping your connection to the server secure.</p>
<h2 id="Unknown_certificate_authority">Unknown certificate authority</h2>
<p>In this case, the SSLHandshakeException occurs because you have a CA that isn’t trusted by the system. It could be because you have a certificate from a new CA that isn’t yet trusted by Android or your app is running on an older version without the CA. More often a CA is unknown because it isn’t a public CA, but a private one issued by an organization such as a government, corporation, or education institution for their own use.</p>
<p>Fortunately, you can teach HttpsURLConnection to trust a specific set of CAs. The procedure can be a little convoluted, so below is an example that takes a specific CA from an InputStream, uses it to create a KeyStore, which is then used to create and initialize a TrustManager. A TrustManager is what the system uses to validate certificates from the server and—by creating one from a KeyStore with one or more CAs—those will be the only CAs trusted by that TrustManager.</p>
<p>Given the new TrustManager, the example initializes a new SSLContext which provides an SSLSocketFactory you can use to override the default SSLSocketFactory from HttpsURLConnection. This way the connection will use your CAs for certificate validation.</p>
<p>Here is the example in full using an organizational CA from the University of Washington:</p>
<pre><code><span class="comment">// Load CAs from an InputStream</span>
<span class="comment">// (could be from a resource or ByteArrayInputStream or ...)CertificateFactory cf = CertificateFactory.getInstance("X.509");</span>
<span class="comment">// From https://www.washington.edu/itconnect/security/ca/load-der.crt</span>
InputStream caInput = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"load-der.crt"</span>));
Certificate ca;
<span class="keyword">try</span> {    
    ca = cf.generateCertificate(caInput);    
    System.<span class="keyword">out</span>.println(<span class="string">"ca="</span> + ((X509Certificate) ca).getSubjectDN());
} <span class="keyword">finally</span> {    
    caInput.close();
}
<span class="comment">// Create a KeyStore containing our trusted </span>
CAsString keyStoreType = KeyStore.getDefaultType();
KeyStore keyStore = KeyStore.getInstance(keyStoreType);
keyStore.load(<span class="keyword">null</span>, <span class="keyword">null</span>);
keyStore.setCertificateEntry(<span class="string">"ca"</span>, ca);
<span class="comment">// Create a TrustManager that trusts the CAs in our KeyStoreString tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();</span>
TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);
tmf.init(keyStore);
<span class="comment">// Create an SSLContext that uses our TrustManager</span>
SSLContext context = SSLContext.getInstance(<span class="string">"TLS"</span>);
context.init(<span class="keyword">null</span>, tmf.getTrustManagers(), <span class="keyword">null</span>);
<span class="comment">// Tell the URLConnection to use a SocketFactory from our SSLContextURL url = new URL("https://certs.cac.washington.edu/CAtest/");</span>
HttpsURLConnection urlConnection =    (HttpsURLConnection)url.openConnection();urlConnection.setSSLSocketFactory(context.getSocketFactory());
InputStream <span class="keyword">in</span> = urlConnection.getInputStream();
copyInputStreamToOutputStream(<span class="keyword">in</span>, System.<span class="keyword">out</span>);
</code></pre><p>With a custom TrustManager that knows about your CAs, the system is able to validate that your server certificate come from a trusted issuer.</p>
<p>Caution: Many web sites describe a poor alternative solution which is to install a TrustManager that does nothing. If you do this you might as well not be encrypting your communication, because anyone can attack your users at a public Wi-Fi hotspot by using DNS tricks to send your users’ traffic through a proxy of their own that pretends to be your server. The attacker can then record passwords and other personal data. This works because the attacker can generate a certificate and—without a TrustManager that actually validates that the certificate comes from a trusted source—your app could be talking to anyone. So don’t do this, not even temporarily. You can always make your app trust the issuer of the server’s certificate, so just do it.</p>
<h2 id="Self-signed_server_certificate">Self-signed server certificate</h2>
<p>The second case of SSLHandshakeException is due to a self-signed certificate, which means the server is behaving as its own CA. This is similar to an unknown certificate authority, so you can use the same approach from the previous section.</p>
<p>You can create your own TrustManager, this time trusting the server certificate directly. This has all of the downsides discussed earlier of tying your app directly to a certificate, but can be done securely. However, you should be careful to make sure your self-signed certificate has a reasonably strong key. As of 2012, a 2048-bit RSA signature with an exponent of 65537 expiring yearly is acceptable. When rotating keys, you should check for recommendations from an authority (such as NIST) about what is acceptable.</p>
<h2 id="Missing_intermediate_certificate_authority">Missing intermediate certificate authority</h2>
<p>The third case of SSLHandshakeException occurs due to a missing intermediate CA. Most public CAs don’t sign server certificates directly. Instead, they use their main CA certificate, referred to as the root CA, to sign intermediate CAs. They do this so the root CA can be stored offline to reduce risk of compromise. However, operating systems like Android typically trust only root CAs directly, which leaves a short gap of trust between the server certificate—signed by the intermediate CA—and the certificate verifier, which knows the root CA. To solve this, the server doesn’t send the client only it’s certificate during the SSL handshake, but a chain of certificates from the server CA through any intermediates necessary to reach a trusted root CA.</p>
<p>To see what this looks like in practice, here’s the mail.google.com certificate chain as viewed by the openssl s_client command:</p>
<pre><code><span class="header">$ openssl s_client -connect mail.google.com:443
---</span>
Certificate chain
<span class="code"> 0 s:/C=US/ST=California/L=Mountain View/O=Google Inc/CN=mail.google.com</span>
<span class="code">   i:/C=ZA/O=Thawte Consulting (Pty) Ltd./CN=Thawte SGC CA</span>
<span class="code"> 1 s:/C=ZA/O=Thawte Consulting (Pty) Ltd./CN=Thawte SGC CA</span>
<span class="header">   i:/C=US/O=VeriSign, Inc./OU=Class 3 Public Primary Certification Authority
---</span>
</code></pre><p>This shows that the server sends a certificate for mail.google.com issued by the Thawte SGC CA, which is an intermediate CA, and a second certificate for the Thawte SGC CA issued by a Verisign CA, which is the primary CA that’s trusted by Android.</p>
<p>However, it is not uncommon to configure a server to not include the necessary intermediate CA. For example, here is a server that can cause an error in Android browsers and exceptions in Android apps:</p>
<pre><code><span class="header">$ openssl s_client -connect egov.uscis.gov:443
---</span>
Certificate chain
<span class="code"> 0 s:/C=US/ST=District Of Columbia/L=Washington/O=U.S. Department of Homeland Security/OU=United States Citizenship and Immigration Services/OU=Terms of use at www.verisign.com/rpa (c)05/CN=egov.uscis.gov</span>
<span class="header">   i:/C=US/O=VeriSign, Inc./OU=VeriSign Trust Network/OU=Terms of use at https://www.verisign.com/rpa (c)10/CN=VeriSign Class 3 International Server CA - G3
---</span>
</code></pre><p>What is interesting to note here is that visiting this server in most desktop browsers does not cause an error like a completely unknown CA or self-signed server certificate would cause. This is because most desktop browsers cache trusted intermediate CAs over time. Once a browser has visited and learned about an intermediate CA from one site, it won’t need to have the intermediate CA included in the certificate chain the next time.</p>
<p>Some sites do this intentionally for secondary web servers used to serve resources. For example, they might have their main HTML page served by a server with a full certificate chain, but have servers for resources such as images, CSS, or JavaScript not include the CA, presumably to save bandwidth. Unfortunately, sometimes these servers might be providing a web service you are trying to call from your Android app, which is not as forgiving.</p>
<p>There are two approaches to solve this issue:</p>
<ul>
<li>Configure the server to include the intermediate CA in the server chain. Most CAs provide documentation on how to do this for all common web servers. This is the only approach if you need the site to work with default Android browsers at least through Android 4.2.</li>
<li>Or, treat the intermediate CA like any other unknown CA, and create a TrustManager to trust it directly, as done in the previous two sections.</li>
</ul>
<h2 id="Common_Problems_with_Hostname_Verification">Common Problems with Hostname Verification</h2>
<p>As mentioned at the beginning of this article, there are two key parts to verifying an SSL connection. The first is to verify the certificate is from a trusted source, which was the focus of the previous section. The focus of this section is the second part: making sure the server you are talking to presents the right certificate. When it doesn’t, you’ll typically see an error like this:</p>
<pre><code>java.io.IOException: Hostname <span class="string">'example.com'</span> was <span class="operator">not</span> verified
        <span class="keyword">at</span> libcore.net.<span class="keyword">http</span>.HttpConnection.verifySecureSocketHostname(HttpConnection.java:<span class="number">223</span>)
        <span class="keyword">at</span> libcore.net.<span class="keyword">http</span>.HttpsURLConnectionImpl$HttpsEngine.connect(HttpsURLConnectionImpl.java:<span class="number">446</span>)
        <span class="keyword">at</span> libcore.net.<span class="keyword">http</span>.HttpEngine.sendSocketRequest(HttpEngine.java:<span class="number">290</span>)
        <span class="keyword">at</span> libcore.net.<span class="keyword">http</span>.HttpEngine.sendRequest(HttpEngine.java:<span class="number">240</span>)
        <span class="keyword">at</span> libcore.net.<span class="keyword">http</span>.HttpURLConnectionImpl.getResponse(HttpURLConnectionImpl.java:<span class="number">282</span>)
        <span class="keyword">at</span> libcore.net.<span class="keyword">http</span>.HttpURLConnectionImpl.getInputStream(HttpURLConnectionImpl.java:<span class="number">177</span>)

  <span class="keyword">at</span> libcore.net.<span class="keyword">http</span>.HttpsURLConnectionImpl.getInputStream(HttpsURLConnectionImpl.java:<span class="number">271</span>)
</code></pre><p>One reason this can happen is due to a server configuration error. The server is configured with a certificate that does not have a subject or subject alternative name fields that match the server you are trying to reach. It is possible to have one certificate be used with many different servers. For example, looking at the google.com certificate with openssl s_client -connect google.com:443 | openssl x509 -text you can see that a subject that supports <em>.google.com but also subject alternative names for </em>.youtube.com, *.android.com, and others. The error occurs only when the server name you are connecting to isn’t listed by the certificate as acceptable.</p>
<p>Unfortunately this can happen for another reason as well: virtual hosting. When sharing a server for more than one hostname with HTTP, the web server can tell from the HTTP/1.1 request which target hostname the client is looking for. Unfortunately this is complicated with HTTPS, because the server has to know which certificate to return before it sees the HTTP request. To address this problem, newer versions of SSL, specifically TLSv.1.0 and later, support Server Name Indication (SNI), which allows the SSL client to specify the intended hostname to the server so the proper certificate can be returned.</p>
<p>Fortunately, HttpsURLConnection supports SNI since Android 2.3. Unfortunately, Apache HTTP Client does not, which is one of the many reasons we discourage its use. One workaround if you need to support Android 2.2 (and older) or Apache HTTP Client is to set up an alternative virtual host on a unique port so that it’s unambiguous which server certificate to return.</p>
<p>The more drastic alternative is to replace HostnameVerifier with one that uses not the hostname of your virtual host, but the one returned by the server by default.</p>
<p>Caution: Replacing HostnameVerifier can be very dangerous if the other virtual host is not under your control, because a man-in-the-middle attack could direct traffic to another server without your knowledge.</p>
<p>If you are still sure you want to override hostname verification, here is an example that replaces the verifier for a single URLConnection with one that still verifies that the hostname is at least on expected by the app:</p>
<pre><code><span class="comment">// Create an HostnameVerifier that hardwires the expected hostname.</span>
<span class="comment">// Note that is different than the URL's hostname:</span>
<span class="comment">// example.com versus example.org</span>
HostnameVerifier hostnameVerifier = <span class="keyword">new</span> HostnameVerifier() {  

    @Override    <span class="keyword">public</span> boolean <span class="title">verify</span>(String hostname, SSLSession session) {        
        HostnameVerifier hv =            HttpsURLConnection.getDefaultHostnameVerifier();        
        <span class="keyword">return</span> hv.verify(<span class="string">"example.com"</span>, session);    
}};
<span class="comment">// Tell the URLConnection to use our HostnameVerifier</span>
URL url = <span class="keyword">new</span> URL(<span class="string">"https://example.org/"</span>);
HttpsURLConnection urlConnection =    (HttpsURLConnection)url.openConnection();
urlConnection.setHostnameVerifier(hostnameVerifier);
InputStream <span class="keyword">in</span> = urlConnection.getInputStream();
copyInputStreamToOutputStream(<span class="keyword">in</span>, System.<span class="keyword">out</span>);
</code></pre>
      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2014/12/26/android-test-sample/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          Google&#39;s Testing Tools For Android --- Espresso
        
      </div>
    </a>
  
  
    <a href="/2014/12/24/git-usage/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">Git Usage</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>


<div class="share">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">分享到：</span>
		<a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
		<a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>



  <section id="comments">
    <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="post-android-https" data-title="﻿Security with HTTPS and SSL" data-url="http://blog.suweya.net/2014/12/25/android-https/"></div>
    <!-- 多说评论框 end -->
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
    var duoshuoQuery = {short_name:'suweya'};
      (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0]
         || document.getElementsByTagName('body')[0]).appendChild(ds);
      })();
      </script>
    <!-- 多说公共JS代码 end -->
  </section>
  


</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2015 迷途
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">

  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>



<script src="/js/mobile.js" type="text/javascript"></script>

<script src="/js/main.js" type="text/javascript"></script>







  </div>
</body>
</html>